'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/kubernetes/handbook/posts/part1-container/ch01-kn/base/','title':"Base",'section':"Ch01 Kn",'content':"   项目 简介     \rmoby 继承于原先的 docker项目，由社区维护的开源项目   \rdocker-ce 开源项目，基于moby项目的免费容器产品，由docker公司维护   docker-ee 闭源，docker公司的商业产品    容器\r#\r\r容器 是一个视图隔离、资源可限制、独立文件系统的进程集合\n容器的边界\r#\r\r容器技术的核心功能，通过约束和修改进程的动态表现，从而为其创建一个 \u0026ldquo;边界\u0026rdquo;\n对于 Docker 等大多数的 Linux Container 来讲，约束是通过 Cgroups 技术实现，修改进程的的视图则是通过 Namespace 实现的\n一个正在运行的 Docker Container 其实是一个 启用了多个 Linux Namespace 的应用进程，该进程可用的资源，受到 Cgroups 限制\nNamespace\r#\r\rNamespace 是 Linux Kernel 的一个功能，可以隔离系统资源，当前共有 6 种 Namespace\n   Namespace 系统调用参数 内核版本     Mount Namespace CLONE_NEWNS 2.4.19   UTS Namespace CLONE_NEWUTS 2.6.19   IPC Namespace CLONE_NEWIPC 2.6.19   PID Namespace CLONE_NEWPID 2.6.24   Network Namespace CLONE_NEWNET 2.6.29   User Namespace CLONE_NEWUSER 3.8    Namespace 的 API 调用主要设计到三个系统调用\n clone(): 创建新的进程，根据上述的系统调用参数来判断需要创建哪种 Namespace unshare(): 将进程从 某个 Namespace 中移出 setns(): 将进程加入到 Namespace 中  由此看出，容器实际上就是创建容器进程的时候，指定进程需要启用的一组 Namespace 参数，使得容器只能看到当前 Namespace 限定的资源、文件、设备、状态、配置等；所以说 容器只是一种特殊的进程\nCgroups\r#\r\rControl Groups， 提供了对一组进程以及其子进程进行资源限制、控制和统计的能力，这里的资源包括：CPU、内存、存储、网络等；还可以对进程优先级设置、审计、挂起恢复等\nLinux对外暴露的操作接口文件是：/sys/fs/cgroup\n"});index.add({'id':1,'href':'/kubernetes/handbook/posts/part1-container/ch02-runtime/write-docker/','title':"Write Docker",'section':"Ch02 Runtime",'content':"推荐阅读\r#\r\r\r《自己动手写Docker》 使用 go 实现了简单的 runtime 引擎，强烈推荐\n阅读笔记\r#\r\r书籍中相关的知识点有点老旧，整体写下来存在很多坑，后续会把相应的每个章节的坑在本文进行补充\n项目地址：\rhttps://github.com/AbyssViper/mydocker\n"});})();